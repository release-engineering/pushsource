from collections import Mapping, Sequence, Iterator, Iterable, MutableSequence
from concurrent.futures import Executor, Future
from queue import Queue
from threading import RLock as ReentrantLock
from types import TracebackType
from typing import Any, Optional, Union, Type, ClassVar, Final, NoReturn

from koji import ClientSession, VirtualCall

from pushsource import Source, RpmPushItem, OperatorManifestPushItem
from pushsource._impl.model.base import PushItem_co
from pushsource.type_aliases import MaybeString, JsonObject

# TODO: for now using Union[str, int] until I figure out
#  which is really intended. This actually might be the best
#  option after all, but I need to investigate
Id = Union[str, int]

CACHE_LOCK: ReentrantLock

RETRY_ARGS: Mapping[str, Any]

class ListArchivesCommand(object):
    def __init__(self, build: Mapping[str, Any]) -> None: ...
    build: Mapping[str, Any]
    # TODO: is VirtualCall correct for this type?
    call: Optional[VirtualCall] = ...
    def execute(self, source: "KojiSource", session: ClientSession) -> int: ...
    def save(self, source: "KojiSource", koji_queue: Queue) -> None: ...

class GetBuildCommand(object):
    def __init__(self, ident: int, list_archives: bool = ...) -> None: ...
    indent: int
    list_archives: bool = ...
    # TODO: is VirtualCall correct for this type?
    call: Optional[VirtualCall] = ...
    def execute(self, source: "KojiSource", session: ClientSession) -> int: ...
    def save(self, source: "KojiSource", koji_queue: Queue) -> None: ...

class GetRpmCommand(object):
    def __init__(self, indent: int) -> None: ...
    indent: int
    # TODO: is VirtualCall correct for this type?
    call: Optional[VirtualCall] = ...
    def execute(self, source: "KojiSource", session: ClientSession) -> int: ...
    def save(self, source: "KojiSource", koji_queue: Queue) -> None: ...

class KojiSource(Source):
    _BATCH_SIZE: Final[ClassVar[int]]
    _koji_session: ClientSession
    def __init__(
        self,
        url: str,
        dest: MaybeString,
        rpm: Optional[Sequence[Id]] = ...,
        module_build: Optional[Sequence[Id]] = ...,
        module_filter_filename: Optional[Sequence[str]] = ...,
        container_build: Optional[Sequence[Id]] = ...,
        signing_key: Optional[Sequence[str]] = ...,
        basedir: Optional[str] = ...,
        threads: int = ...,
        timeout: int = ...,
        cache: Optional[Mapping[str, Any]] = ...,
        executor: Optional[Executor] = ...,
    ) -> None: ...
    def __enter__(self) -> "KojiSource": ...
    def __exit__(
        self,
        exc_type: Type[BaseException],
        exc_val: BaseException,
        exc_tb: TracebackType,
    ) -> None: ...
    def __iter__(self) -> Iterator[PushItem_co]: ...
    # TODO: the return type here feels hacky, but is accurate
    def _koji_check(self) -> Optional[NoReturn]: ...
    def _koji_get_version(self) -> str: ...
    # TODO: reasonably sure based on the Fedora Koji XML-RPC
    #  docs for getRPM, getBuild, and getArchive that what is
    #  the map returned by those API calls is what's stored in
    #  the cache. Since it is not unlike a JSON object I am sticking
    #  with a JsonObject return type for now
    def _get_rpm(self, rpm: str) -> JsonObject: ...
    def _get_build(self, build_id: Id) -> JsonObject: ...
    def _get_archives(self, build_id: Id) -> JsonObject: ...
    # TODO: maybe JsonObject is appropriate for the meta parameter type
    def _push_items_from_rpm_meta(
        self, rpm: str, meta: Mapping[str, Any]
    ) -> Sequence[RpmPushItem]: ...
    def _module_filtered(self, file_path: str) -> bool: ...
    def _get_module_name(self, nvr: str, file_path: str) -> str: ...
    # TODO: maybe JsonObject is appropriate for the meta parameter type
    def _push_items_from_module_build(
        self, nvr: str, meta: Mapping[str, Any]
    ) -> Sequence[PushItem_co]: ...
    def _push_items_from_container_build(self, nvr: str, meta: Mapping[str, Any]) -> Sequence[PushItem_co]: ...
    def _get_operator_item(self, nvr: str, meta: Mapping[str, Any], archives: Iterable[Mapping[str, Any]]) -> OperatorManifestPushItem: ...
    def _rpm_futures(self) -> Sequence[Future[PushItem_co]]: ...
    def _modulemd_futures(self) -> Sequence[Future[PushItem_co]]: ...
    def _container_futures(self) -> Sequence[Future[PushItem_co]]: ...
    def _do_fetch(self, koji_queue: Queue, exceptions: MutableSequence) -> None: ...
